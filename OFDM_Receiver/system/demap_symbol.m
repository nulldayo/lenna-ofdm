% #########################################################################
%
% University of Rostock
% Faculty of Informatics and Electrical Engineering
% Institute of Communications Engineering
%
% M.Sc. Andre Angierski
% Version: #VERSION_DUMMY#
%
% #########################################################################
%
% Demodulates and demaps the received symbol vector "y = h*x + n" for a 
% given mapping. The outputs are the estimated bit vector c_hat (without  
% reliability information) and Lout (with reliability information).
% Note that the SNR value must be provided in dB.
%
% function [c_hat] = demap_symbol(y, mapping)
% function [c_hat] = demap_symbol(y, mapping, padded_bits)
% function [c_hat] = demap_symbol(y, mapping, padded_bits, EsNo_dB)
% function [c_hat] = demap_symbol(y, mapping, padded_bits, EsNo_dB, Lc_a)
% function [c_hat] = demap_symbol(y, mapping, padded_bits, EsNo_dB, Lc_a, h_hat, alg)
% function [c_hat, Lout] = demap_symbol(...)
%
% INPUTS:
%       y           -   disturbed symbols
%       mapping     -   mapping structure, generated by "generate_mapping()"
%       padded_bits -   number of bits, added by "map_symbol()" because of 
%                       zero padding
%                       (optional, default == 0)
%       EsNo_dB     -   Signal-to-Noise-Ratio in dB, required to compute 
%                       soft values
%                       (optional, default == 0)
%       Lc_a         -   a priori LLRs for each output bit, for computation 
%                       of soft values 
%                       (optional, default == [0 0 0 ...])
%       h_hat        -  Estimation of channel-coefficient used for 
%                       equalization.
%                       For channel "y = h*x + n", perfect channel
%                       estimation is given by "h_hat = h". If your channel
%                       model does not influence amplitude or phase of your
%                       signal (e.g. pure AWGN channel: y = x + n), you
%                       can set "h_hat = 1".
%                       (optional, default == 1)
%       algorithm    -   defines used algorithm to compute soft values
%                           == 'MAP' --> exact LLR calculation 
%                           == 'MAX' --> Max-Log-Approximation
%                       (optional, default == 'MAX')
% OUTPUTS:
%       c_hat     -   output of demapped bit vector (hard values)
%       Lout      -   Log Likelihood Ratios (soft values)
%
% EXAMPLES:
%     EsNo            = 1;
%     y               = 0.1 - 0.9i;
%     mapping_scheme  = generate_mapping(4, 'PSK');
%
%     show_mapping(mapping_scheme);
%     hold('on')
%     scatter(real(y), imag(y), 'ro', 'MarkerFaceColor', 'r')
%     hold('off')
%
%     [c_hat, Lout]   = demap_symbol(y, mapping_scheme, 0, EsNo)
%
function [c_hat, Lout] = demap_symbol(y, mapping, padded_bits, EsNo_dB,  Lc_a, h_hat, algorithm)

%% Initialisation

% define modulation
m = mapping.m;

% define infinity
inf = 10^6;

%check variables

if ~exist('padded_bits', 'var') || isempty(padded_bits)
    padded_bits = 0; % no zero padding
else
    if padded_bits < 0
        error('The number of padded bits need to be positive!');
    end
end

if ~exist('EsNo_dB', 'var') || isempty(EsNo_dB)
    EsNo_dB = 0;
    if nargout > 1
        warning('DEMAP_SYMBOL:NO_SNR', 'The soft-value depends on the actual SNR! You should add the "EsNo_dB" parameter to the call of the demapper-function. (Default: Es/No = 0dB)')
    end
end
if ~isscalar(EsNo_dB)
    error('The argument "EsNo_dB" need to be a scalar!')
end

if ~exist('Lc_a', 'var') || isempty(Lc_a)
    Lc_a = zeros(length(y)*m - padded_bits,1);
else
    if size(Lc_a, 1) < size(Lc_a, 2)
        Lc_a = Lc_a.';
    end
    if numel(Lc_a) ~= (length(y)*m - padded_bits)
        error('The length of vector "Lc_a" is not correct! Check the number of padded_bits. ("length(Lc_a)" should be equal to the "length(y) * m - padded_bits")');
    end
end

%zero padding
Lc_a = [Lc_a; +inf*ones(padded_bits,1)]; %add large LLR for added zeros
if mod(length(Lc_a),m) ~= 0
    error('The length of vector Lc_a is not correct! Check the number of padded_bits.');
end

if ~exist('h_hat', 'var') || isempty(h_hat)
    h_hat = 1;
end
if ~isscalar(h_hat)
    error('The estimation of the channel coefficient "h_hat" must be a scalar value!')
end

if ~exist('algorithm', 'var') || isempty(algorithm)
    algorithm = 'MAX';
end

%check orientation of symbol vector
if size(y, 1) < size(y, 2)
    y = y.';
end

% load mapping scheme
alphabet_bin = mapping.alphabet.binary;
alphabet_comp = mapping.alphabet.complex;

% define scalar Es/No
EsNo_lin = 10^(EsNo_dB/10);

% number of symbols
N_symbols = length(y);

% reshape a-priori LLRs
Lc_a = reshape(Lc_a,m,length(Lc_a)/m).';

%% find positions of zeros and ones in symbols 

% allocate memory
% pointer on positions where bits are 0/1
ptr0 = zeros(m,2^m / 2);
ptr1 = zeros(m,2^m / 2);

% Analyze binary bitmapping
for i=1:m
    % pointer on positions 0/1 in bit-tupels at specific bit position
    ptr0(i,:)= find(alphabet_bin(i,:)==0);
    ptr1(i,:)= find(alphabet_bin(i,:)==1);
end

% -------------------------------------------------------------------------
%% Hard decision demodulation algorithm
% -------------------------------------------------------------------------
if nargin < 2
    % Hard Decision
    % calculate distance between distrubed alphabet and received symbols
    dist = abs(ones(N_symbols,1)*alphabet_comp * h_hat - y*ones(1,2^m));

    % find minimum distance
    [min_dis,min_i] = min(dist,[],2);

    % chosse binary digits from alphabet
    c_hat = alphabet_bin(:,min_i).';

    % reshape bit order
    c_hat = reshape(c_hat.',N_symbols*m,1);
    
% -------------------------------------------------------------------------
%% Soft decision demodulation algorithm
% -------------------------------------------------------------------------
else 
    % Soft decision

    % allocate memory
    % m-tupel of bits in each row for soft decision values
    Lout = zeros(N_symbols,m);

    % Calculate exact solution -------------------------------------------
    if strcmpi(algorithm,'MAP')
        % calculate intrinsic information L_i
        L_i = exp( -abs(y * ones(1,2^m) - ...
            h_hat * ones(N_symbols,1) *alphabet_comp).^2 * EsNo_lin );

        % old implementation (very slow):
        %{
         for l=1:N_symbols
             apriori = exp( - alphabet_bin.' * Lc_a(l,:).' );
             for n=1:m
                 p0 = L_i(l,ptr0(n,:)) * apriori(ptr0(n,:));
                 p1 = L_i(l,ptr1(n,:)) * apriori(ptr1(n,:));
                 Lout(l,n) = log(p0./p1);
             end
         end
        %}
        % new implementation as C-mex-file:

        Lout = demap_symbol_mex(m, N_symbols, L_i, Lc_a.', ptr0, ptr1, double(alphabet_bin.') );
        %TODO: update VisualStudio-Mex-Debugger-Project. (Filename has changed)
        
        if numel(find(isnan(Lout)))>0
            save('workspace.mat');
            error('Implementation of MEX-File returns NaN-values! Workspace has been saved to "workspace.mat"! (This happens for high SNRs and "superposition mapping", since there are numerical problems! In that case it would also happen without MEX-implementation.)');
        end
        
        % Change format to row vector
        Lout = reshape(Lout.',N_symbols*m,1);

        % find maximimum finite LLR
        L_max = max(abs(Lout(isfinite(Lout) & (Lout~=0))));

        if isempty(L_max)
            L_max = inf;
        end

        % find all infinite LLRs (+inf)
        ptr = find((Lout>0) & isinf(Lout));
        if ~isempty(ptr)
            Lout(ptr) = L_max;
        end

        % find all infinite LLRs (-inf)
        ptr = find(isinf(Lout) & (Lout<0));
        if ~isempty(ptr)
            Lout(ptr) = -L_max;
        end

    % Calculate Approximation --------------------------------------------
    elseif strcmpi(algorithm,'MAX')

        % Calculate intrinsic information
        L_i = -abs(y *ones(1,2^m) - ...
              h_hat * ones(N_symbols,1) *alphabet_comp).^2 * EsNo_lin;

        for l=1:N_symbols

            % determine apriori information
            apriori = - alphabet_bin.' * Lc_a(l,:).';
            
            for n=1:m
                p0 = max( L_i(l,ptr0(n,:)) + apriori(ptr0(n,:)).' );
                p1 = max( L_i(l,ptr1(n,:)) + apriori(ptr1(n,:)).' );
                Lout(l,n) = p0-p1;
            end
        end

        % Change format to row vector
        Lout = reshape(Lout.',N_symbols*m,1);
    else
        error('Unsupported algorithm!');
    end

    % Compute hard value
    c_hat = Lout <= 0;
end

%% remove bits added by zero padding
if nargout > 1
    Lout = Lout(1:(numel(Lout)-padded_bits));
    Lout = Lout.';
end

c_hat = c_hat(1:(numel(c_hat)-padded_bits));
c_hat = c_hat.';


end